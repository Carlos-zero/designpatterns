package com.example.designpatterns.strategyPattern.version_2;

/**
 * 新增了橡胶鸭，普通鸭子会飞，但由于在超类中实现的 fly() 方法，所以会导致橡皮鸭非预期的会飞。
 * 要解决这个问题，我们可以利用继承在橡皮鸭中重写 fly() 方法，就像其重写 quack() 一样。
 * 但这种解法并不合适，如果以后新增子类 【诱饵鸭:DecoyDuck】，诱饵鸭是木头假鸭，不会飞也不会叫，就需要在诱饵鸭中重写超类的方法。
 * 这种利用继承来提供 Duck 的行为，会导致以下的缺点：
 * 1、代码在多个子类重复（重写造成的）。
 * 2、运行时的行为不容易改变。
 * 3、很难知道鸭子的全部行为（因为得知道各个子类进行了怎样的改写）。
 * 4、改变会牵一发动全身，造成其他鸭子不想要的改变（如果子类不重写，默认就是超类的实现）。
 * 另一种方法，使用接口来定义 fly()、quack()，虽然能解决 bug，但因为接口无法复用（必须由使用者实现），
 * 所以，在子类非常多的情况下，每一个子类都需要具体实现，并不是一个好的方法。
 */
public class Main {
    public static void main(String[] args) {
        MallardDuck mallardDuck = new MallardDuck();
        ReadDuck readDuck = new ReadDuck();
        RubberDuck rubberDuck = new RubberDuck();
    }
}

/*
    ------------------------------------
    外观->绿头鸭！
    叫声->呱呱叫！
    泳姿->水上漂！
    飞翔->会飞的鸭！
    ------------------------------------
    ------------------------------------
    外观->红头鸭！
    叫声->呱呱叫！
    泳姿->水上漂！
    飞翔->会飞的鸭！
    ------------------------------------
    ------------------------------------
    外观->橡皮鸭！
    叫声->吱吱叫！
    泳姿->水上漂！
    飞翔->会飞的鸭！
    ------------------------------------
*/